
# Маршрутизация. SimpleMVC

Когда пользователь запрашивает какую-либо страницу нашего сайта (напр. кликая на ссылку, которая ведет на одна из страниц сайта), сервер получается адрес запроса и делает его доступным интерпретару PHP.

Таким образом, php-приложению требуется понять, какие именно действия необходимо сделать в ответ на конкретный запрос. 
Процесс выбора этих конкретных действий и есть _процесс марутизации_ запроса пользователя.

## Понятие маршрута

Для того, чтобы дальнейшие рассуждения были понятны, введем _понятние маршрута_.

**Маршрут** -- уникальная _строка_, которая соответствует действию контроллера.

Один маршрут должен соответствовать одному действию одного контроллера, т.е. является _уникальным_ (иначе Ядро системы не сможет понять какие именно действия выполнять).

Также можно сказать, что маршрут - это _адрес действия_ в списке действий, которые умеет выполнять наша система.

## Главный вопрос маршрутизации

Далее рассмотрим подробнее _как именно система понимает какой именно [контроллер](Controllers.md) (и какое его действие) соответствует данному маршруту_.


## Откуда берется строка маршрута

Маршрут (строка маршрута) - внутренее понятие фреймворка (в данном случае `SMVC`),
по сути это _абстракция_ - некая строка, которая обозначает адрес действия.
Но откуда её взять в реальной жизни?

Ответ такой: маршрут может получаться из данных адреса запроса клиента, направленного серверу.

Таким образом, логически система выполняет действия в таком порядке: 

1. Анализ HTTP `Запроса` клиента.
2. Получение `строки маршрута` из `Запроса` (ниже посмотрим как это происходит в `smvc`, 
получать строку маршрута можно _разными способами_, такой подход делает систему более гибкой)
3. Получение и вызов `действия контроллера`, соответствующего `маршруту`.


## Схема работы приложения

Кратко описать процесс работы фреймворка можно так:

1. У Приложения есть единственный файл (т.н. "**точка входа**" в нашем случае это файл [web/index.php](https://github.com/it-for-free/SimpleMVC-example/blob/master/web/index.php)), с которого начинается обработка _любого_ запроса пришедшего от клиента (см. [подробнее о Клиент-Серверной архитектуре](http://fkn.ktu10.com/?q=node/9330)). Т.е. это означается что _все_ скрипты нашего сайта начинают работать именно с этого файла.
2. В точке входа Приложение получается экземпляр класса `\ItForFree\SimpleMVC\Application` ([см. реализацию](https://github.com/it-for-free/SimpleMVC/blob/master/src/Application.php) - отвечает за работу ядра в целом, подключая по мере необходимости другие части ярда), устанавливает ему [конфигурацию (через слияние основного и локального файлов конфигурации)](Config.md) и запускает функционал Ядра, вызвав метод `run()`:
 
 ```php
 \ItForFree\SimpleMVC\Application::get()
    ->setConfiguration($config)
    ->run();
 ```
3. Вызов метода `run()` фактически запускает функционал ядра, который, анализируя текущее состояние адреса страницы (URL), принимает решение о том, _какой контроллер отвечает за данный адрес_ и какое именно _действие котроллера_ должно быть вызвано. Далее  фрагмент кода из метода `run()`:

```php
// .....
$route = $this->getConfigObject('core.router.class')::getRoute();
/**
* @var \ItForFree\SimpleMVC\Router\WebRouter
*/
$Router = $this->getConfigObject('core.router.class');
$Router->callControllerAction($route); // определяем и вызываем нужно действие контроллера
// .....
```
-- как видим за процесс определения имени контроллера, имени действий и их вызов происходят в методе `callControllerAction()`, реализованном  уже другой классе Ядра, а именно `\ItForFree\SimpleMVC\Router\WebRouter` ([исх. код](https://github.com/it-for-free/SimpleMVC/blob/master/src/WebRouter.php)).


При этом код:
```php
$route = $this->getConfigObject('core.router.class')::getRoute();
```
-- отвечает за получение `строки маршрута`, для чего статический вызывается метод `getRoute()` класса, лежащего в кофиге приложения по адресу core.router.class - подразумевается, что этот метод этого класса отвечает за реализацию процесса получения строки маршрута.


**Ещё раз схема работы, но теперь кратко**

Таким, образом можно сказать, что взаимодействие Приложения и Ядра в части маршрутизации проходят по цепочке в таком порядке (по времени работы кода Приложения или Ядра):

 1. `Приложение` (запускает функционал ядра через `Applliction->run()` в своей точке входа)
 2. `Ядро` (используя свои классы определяет контроллер и действие, соответствующие маршруту (url) создает экземпляр контроллера и вызывает на нем метод)
 3. `Приложение` (выполняется код действий контроллера, и все что это действие вызовет)


## Представление маршрута в адресе страницы

Маршрут из адреса запроса может извлекаться _разными способами_ - это зависит от внутренней логики бэкэнд-приложения.

### Маршрут как часть URL

Например, есть адрес:
```
http://example.loc/user/list
```

Для Приложения интерес здесь предствляет та часть URL, что идет после доменного имени - в данном случае это `user/list`, ведь именно её можно ассоциировать в логике системы с каким-нибудь дейтсвием (в данном случае логично напрашивается вывод списка пользователей).

### Маршрут как один из GET-параметров 

Рассмотрим пример маршрута из Приложения SimpleMVC-example, авторизуемся под админом (его учетная запись есть в дампе стартовой БД) и перейдем на страницу списка пользователей, тогда в адресной строке браузера мы увидим адрес вроде:

```
http://smvc.loc/index.php?route=admin/adminusers/index
```

Здесь значением маршрута для движка (в нашем случае - Ядра SimplrMVC) будет являтся значение GET-параметра `route` в данном случае это значение равно `admin/adminusers/index`

## Как именно маршрут сопоставляется с действием контроллера

Как уже говорилось выше, за сопоставление отвечает `\ItForFree\SimpleMVC\Router\WebRouter`

-- изучите работу его метода `callControllerAction()`, этот метод получает на вход строку машрута и далее пытается по ней (используя собственную логику) определить:
1. имя класса контроллера
2. имя действия контроллера (т.е. фактически имя метода контроллера)

Если оба пунта удается выполнить - то создается объект класса контроллера и вызывается его действие, т.е. в дело вступает код, написанный программистом, использующим `SMVC`

